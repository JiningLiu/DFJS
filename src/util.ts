import * as BabelTypes from "@babel/types"

import {
  ArrayExpression,
  Identifier,
  Literal,
  NullLiteral,
  ObjectExpression,
  RegExpLiteral,
  TemplateLiteral,
} from "../node_modules/@babel/types/lib/index"

export type ValidLiteral = Exclude<
  Literal,
  NullLiteral | RegExpLiteral | TemplateLiteral
>
// These excluded types will be parsed by visitors before being processed here ðŸ‘†
export function getValue(
  t: typeof BabelTypes,
  value: ValidLiteral | Identifier
) {
  if (t.isIdentifier(value)) return (value as Identifier).name
  else return (value as ValidLiteral).value
}

export function getVarScope(identifier: Identifier) {
  // Mapping of variable type annotations to internal variable scope names
  // Courtesy of https://github.com/UserUNP/sparkscript/blob/master/src/values/Variable.ts
  const varScopes = {
    local: "local",
    game: "unsaved",
    save: "saved",
  }

  //@ts-ignore I cannot figure out babel types to save my life
  const scope = identifier.typeAnnotation.typeAnnotation.typeName.name
  if (varScopes[scope as keyof typeof varScopes] == null)
    throw new Error(
      `Variable scope ${scope} is not recognized. Acceptable scope values are: ${Object.keys(
        varScopes
      )}`
    )
  return varScopes[scope as keyof typeof varScopes]
}

export function generateUniqueVarID() {
  const chars =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-=_+~`[];':\",<>./?".split(
      ""
    )
  let id = ""
  for (let i = 0; i < 8; i++)
    id += chars[Math.floor(Math.random() * chars.length)]
  return id
}

export function getBlockObject(
  t: typeof BabelTypes,
  blockType: string,
  blockAction: string,
  args: any[] = []
) {
  return t.objectExpression([
    t.objectProperty(t.stringLiteral("id"), t.stringLiteral("block")),
    t.objectProperty(t.stringLiteral("block"), t.stringLiteral(blockType)),
    t.objectProperty(
      t.stringLiteral("args"),
      t.objectExpression([
        t.objectProperty(t.stringLiteral("items"), t.arrayExpression(args)),
      ])
    ),
    t.objectProperty(t.stringLiteral("action"), t.stringLiteral(blockAction)),
  ])
}

export function getArgObject(
  t: typeof BabelTypes,
  slot: number,
  data: object,
  type: string
) {
  // 'data' here should be JSON not a babel expression, it gets parsed anyway in this function ðŸ‘‡
  return t.objectExpression([
    t.objectProperty(
      t.stringLiteral("item"),
      t.objectExpression([
        t.objectProperty(t.stringLiteral("data"), parseValueToLiteral(t, data)), // data such as e.g. var name & scope
        t.objectProperty(t.stringLiteral("id"), t.stringLiteral(type)),
      ])
    ),
    t.objectProperty(t.stringLiteral("slot"), t.numericLiteral(slot)), // The slot that this argument is in the chest
  ])
}

export function getValueType(t: typeof BabelTypes, value: Literal) {
  // Get df value (such as "txt", "num", "var", etc.) from babel object (such as stringLiteral)
  if (t.isStringLiteral(value)) {
    return "txt"
  } else if (t.isNumericLiteral(value)) {
    return "num"
  } else if (t.isIdentifier(value)) {
    return "var"
  } // ... more types (TO DO)
  else {
    throw new Error("Unsupported value type: " + value.type)
  }
}

export function parseValueToLiteral(
  t: typeof BabelTypes,
  value: any
): Literal | ArrayExpression | ObjectExpression {
  // Generated by ChatGPT ðŸ¤ 
  // This is pretty self-explanatory though (I hope)
  if (typeof value === "number") {
    return t.numericLiteral(value)
  } else if (typeof value === "string") {
    return t.stringLiteral(value)
  } else if (typeof value === "boolean") {
    return t.booleanLiteral(value)
  } else if (Array.isArray(value)) {
    return t.arrayExpression(
      value.map((value) => parseValueToLiteral(t, value))
    )
  } else if (typeof value === "object") {
    const properties = Object.entries(value).map(([key, val]) => {
      const keyNode = t.stringLiteral(key)
      const valNode = parseValueToLiteral(t, val)
      return t.objectProperty(keyNode, valNode)
    })
    return t.objectExpression(properties)
  }

  throw new Error("Unsupported value type: " + typeof value)
}
