function getBlockObject(t, blockType, blockAction, args = []) {
  return t.objectExpression([
    t.objectProperty(t.stringLiteral("id"), t.stringLiteral("block")),
    t.objectProperty(t.stringLiteral("block"), t.stringLiteral(blockType)),
    t.objectProperty(
      t.stringLiteral("args"),
      t.objectExpression([
        t.objectProperty(t.stringLiteral("items"), t.arrayExpression(args)),
      ])
    ),
    t.objectProperty(t.stringLiteral("action"), t.stringLiteral(blockAction)),
  ])
}

function getArgObject(t, slot, data, type) {
  // 'data' here should be JSON not a babel expression, it gets parsed anyway in this function ðŸ‘‡
  return t.objectExpression([
    t.objectProperty(
      t.stringLiteral("item"),
      t.objectExpression([
        t.objectProperty(t.stringLiteral("data"), parseValueToLiteral(t, data)), // data such as e.g. var name & scope
        t.objectProperty(t.stringLiteral("id"), t.stringLiteral(type)),
      ])
    ),
    t.objectProperty(t.stringLiteral("slot"), t.numericLiteral(slot)), // The slot that this argument is in the chest
  ])
}

function getValueType(t, value) {
  // Get df value (such as "txt", "num", "var", etc.) from babel object (such as stringLiteral)
  if (t.isStringLiteral(value)) {
    return "txt"
  } else if (t.isNumericLiteral(value)) {
    return "num"
  } else if (t.isVariableDeclaration()) {
    return "var"
  } // ... more types (TO DO)
  else {
    throw new Error("Unsupported value type: " + value.type)
  }
}

function parseValueToLiteral(t, value) {
  // Generated by ChatGPT ðŸ¤ 
  // This is pretty self-explanatory though (I hope)
  if (typeof value === "number") {
    return t.numericLiteral(value)
  } else if (typeof value === "string") {
    return t.stringLiteral(value)
  } else if (typeof value === "boolean") {
    return t.booleanLiteral(value)
  } else if (Array.isArray(value)) {
    return t.arrayExpression(value.map(parse))
  } else if (typeof value === "object") {
    const properties = Object.entries(value).map(([key, val]) => {
      const keyNode = t.stringLiteral(key)
      const valNode = parseValueToLiteral(t, val)
      return t.objectProperty(keyNode, valNode)
    })
    return t.objectExpression(properties)
  }

  throw new Error("Unsupported value type: " + typeof value)
}

export default function ({ types: t }) {
  return {
    visitor: {
      FunctionDeclaration(path) {
        const { id, returnType } = path.node
        // Mapping of function types to internal event code block types
        const eventBlocks = {
          PlayerEvent: "event",
          // ...
        }
        // Get function type in user's code (e.g. function Join(): *PlayerEvent* ðŸ‘ˆ See we're getting this thing)
        const returnTypeId = returnType.typeAnnotation.typeName.name
        // Get equivalent diamondfire id
        const eventType = eventBlocks[returnTypeId]
        if (!eventType)
          // If there's no valid mapping then throw an error ðŸ˜”
          throw new Error(
            `Could not identify the event type of a function. Return type "${returnTypeId}" did not map to a valid event type.`
          )

        // This array will hold all of the objects in this function / soon-to-be DiamondFire thread
        const threadContents = [getBlockObject(t, eventType, id.name)] // We initialize it with only the event / function block object
        // Traverse the function to gather the objects inside the function
        path.traverse({
          VariableDeclarator(path) {
            const { init, id } = path.node
            if (init == null) return // Unitialized variables such as `const example;` do not need to be parsed

            // Mapping of variable type annotations to internal variable scope names
            const varScopes = {
              Game: "unsaved",
            }

            // Push block object to threadContents array above holding the objects in the parent function
            threadContents.push(
              getBlockObject(t, "set_var", "=", [
                getArgObject(
                  t,
                  0,
                  {
                    name: id.name,
                    // ðŸ‘‡ Get internal variable scope of var type annotation in user's code
                    // e.g. `const exampleVariable: *Game*` <-- We're parsing this to a name that df templates understand
                    scope:
                      varScopes[id.typeAnnotation.typeAnnotation.typeName.name],
                  },
                  "var"
                ),
                getArgObject(
                  t,
                  1,
                  {
                    name: init.value,
                  },
                  getValueType(t, init)
                ),
              ])
            )
          },
        })

        // This is the root object of the diamondfire template
        const threadObject = t.objectExpression([
          t.objectProperty(
            t.stringLiteral("blocks"),
            t.arrayExpression(threadContents)
          ),
        ])

        // Final step!!! Replace the original code with the threadObject defined above
        path.replaceWith(threadObject)
      },
    },
  }
}
